{
  "hash": "ab6f1d506c36bbfb79206ee0d3e60bf6",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ndate: 2024-03-01\ntitle: Monte-Carlo Methods for Prediction & Control\nsubtitle: Sample-based Learning Methods\ndescription: \"In this module we learn about Sample based MC methods that allow learning from sampled episodes. We revise our initial algorithm to better handle exploration. In off policy RL we see methods to learn a policy using samples from another policy, corrected using importance sampleing.\"\ncategories:\n  - Coursera\n  - Sample-based Learning Methods\n  - Reinforcement Learning\nkeywords:\n  - Exploring Starts\n  - MC methods\n  - Any visit MC prediction\n  - First visit MC prediction\n  - MC with exploring starts GPI\n  - Monte-Carlo with ∆ê-soft GPI\n  - ∆ê-soft policies\n  - Off-policy learning\n  - Importance sampling\njupyter: python3\nimage: img/nlp-brain-wordcloud.jpg\ntitle-block-banner: /images/banner_black_3.jpg\n---\n\n\n\n\n![RL logo](img/logo.png){.column-margin} \n\n![RL algorithms](img/alg_selector.png){.column-margin group=\"slides\"}\n\n\n::: {.callout-tip .tldr}\n## TL;DR This lesson in a nutshell {.unnumbered}\n\n![in a nutshell](img/in_a_nutshell.jpg)\n\n-   In this module we will embrace the paradigm of \"learning from experience\".\n-   This is called Sample based Reinforcement Learning and it we will let us relax some strong of the requirements of dynamic programming, namely knowing the table of MDP dynamics.\n-   We will first use efficient Monte-Carlo ‚öÖüÉÅ methods for üîÆ prediction problem of estimating $v_\\pi(S)$ value functions and action--value functions $q_\\pi(a)$ from sampled episodes.\n-   We will revise our algorithm to better handle exploration using exploring starts and $\\epsilon$--soft policies.\n-   We will adapt GPI algorithms for use with Mote-Carlo to solve the üéÆ control problem of policy improvement.\n-   With off policy learning learn a policy using samples from another policy, by corrected using importance sampling.\n:::\n\n::: {.callout-tip collapse=\"true\"}\n## Reading {.unnumbered}\n\n-   [x] [RL Book¬ß5.0-5.5 (pp.91-104)](http://incompleteideas.net/book/RLbook2020.pdf#page=91)\n:::\n\n::: callout-note\n## Definitions {.unnumbered}\n\nHere are most of the definitions we need for this module. Let us review them before we start.\n\n::: {#dfn-value}\n\nValue Function $v_\\pi(s)$\n\n:   a state's value is its expected return\n\n:   $v_\\pi(s) \\doteq \\mathbb{E}[G_t|S_t=s]$\n:::\n\n::: {#dfn-action-value}\n\nAction Value Function\n\n:   is the expected return for taking action $a$ in state $s$ if we follow policy $\\pi$\n\n:   $q_\\pi(a) \\doteq \\mathbb{E}[G_t \\vert A_t=a] \\space \\forall a \\in \\{a_1 ... a_k\\}$\n:::\n\n::: {#dfn-bootstrap}\n\nBootstrapping\n\n:   \"learning by guessing from a guess\" or more formally\n\n:   the process of updating an estimate of the value or action-value function based on other estimated values. It involves using the current estimate of the value function to update and improve the estimate itself.\n:::\n\n::: {#dfn-control}\n\nControl\n\n:   to approximate optimal policies using the DP approach of GPI\n:::\n\n::: {#dfn-epsilon-soft}\n\nœµ-Soft Policy\n\n:   A policy in which each possible action is assigned at least $\\epsilon / |A|$ probability.\n:::\n\n::: {#dfn-exploring-starts}\n\nExploring Starts\n\n:   Learning the value or action values of a policy by trying each action starting in each state at least once and then following the policy.\n\n:   This can include taking actions that are not part of the policy.\n:::\n\n::: {#dfn-mc}\n\nMonte-Carlo Methods\n\n:   Estimation methods which relies on repeated random sampling. Also see [Monte-Carlo methods <i class=\"bi bi-wikipedia\"></i>](https://en.wikipedia.org/wiki/Monte_Carlo_method)\n:::\n\n::: {#dfn-on-policy-learning}\n\nOn-policy learning\n\n:   learning a policy $\\pi$ by sampling from $\\pi$\n:::\n\n::: {#dfn-off-policy-learning}\n\nOff-policy learning\n\n:   learning a policy $\\pi$ by sampling from some other policy $\\pi'$\n:::\n\n::: {#dfn-prediction}\n\nPrediction\n\n:   Estimating $v_\\pi(s)$ is called policy evaluation in the DP literature.\n\n    We also refer to it as the Prediction problem [^1]\n:::\n\n::: {#dfn-return}\n\nReturn ($G_t$)\n\n:   $G_0 \\doteq R_1+ \\gamma^1 R_2 + \\cdots+ \\gamma^n R_n$\n\n    i.e. the discounted sum of future rewards\n:::\n\n::: {#dfn-tqabular}\n\nTabular methods\n\n:   RL methods for which the action-values can be represented by a table\n:::\n:::\n\n[^1]: **Prediction** in the sense that we want to predict for $\\pi$ how well it will preforms i.e. its expected returns for a state\n\n-   Sample based methods learning from experience, without having prior knowledge of the underlying MDP model.\n-   We will cover tabular methods in which the action-values can be represented by a table.\n\n# Lesson 1: Introduction to Monte-Carlo Methods\n\n::: callout-note\n### Lesson Learning Goals {.unnumbered}\n\n-   [x] Understand how [Monte-Carlo](#dfn-mc) can be used to estimate $v(s)$ value functions from sampled interaction [\\#](#sec-l1g1)\n-   [x] Identify problems that can be solved using [Monte-Carlo](#dfn-mc) methods [\\#](#sec-l1g2)\n-   [x] Use [Monte-Carlo](#dfn-mc) prediction to estimate the value function for a given policy. [\\#](#sec-l1g3)\n:::\n\n-   After completing the introduction we all think that MDPs and DP are the best?\n-   Alas, Martha burst this bubble, introducing some shortcomings of DP, namely they require us to know a model of the dynamics $p(s,a|s',r)$ and rewards $r$ of the MDP to estimate $v(s)$ or $q(a)$.\n\n![MC methods for Policy evaluation](img/rl-mc-methods.png){.column-margin group=\"slides\"}\n\nlet us now try to understand how [Monte-Carlo](#dfn-mc) can be used to estimate $v(s)$ value functions from sampled interaction.\n\n![12 dice](img/rl-mc-12-dice.png){.column-margin group=\"slides\"}\n\n::: {#exm-dp-dice}\n### Rolling 12 Dice {.unnumbered}\n\n-   Say our MDP requires rolling 12 dice.\n    -   this is probably intractable to estimate theoretically using DP.\n    -   this is likely to be error prone (particularly and constitutionally).\n    -   this will be easy to estimate using MC methods\n:::\n\n-   For most MDPs knowing the dynamics and rewards is an unreasonably strong requirement.\n-   If we can treat this like a bandit problem we can try to use the long term averages rewards to estimate value of a state\n\n![MC bandits](img/rl-mc-bandit.png){.column-margin group=\"slides\"}\n\nmore formally we can use the MC value prediction algorithm.\n\n------------------------------------------------------------------------\n\nNext we present an algorithm for estimating the value function of a policy $\\pi$ using MC methods.\n\n::: {#nte-mc-value-prediction-any-visit .callout-note .alg}\n### MC prediction any visit for estimating $V \\approx v_\\pi$ {#alg-mc-prediction-any-visit}\n\n``` pseudocode\n#| label: alg-mc-prediction-any-visit\n#| html-indent-size: \"1.2em\"\n#| html-comment-delimiter: \"#\"\n#| html-line-number: true\n#| html-line-number-punc: \":\"\n#| html-no-end: false\n#| pdf-placement: \"htb!\"\n#| pdf-line-number: true\n\\begin{algorithm}\n\\caption{MCFirstVisitValuePrediction($\\pi$)} \n\\begin{algorithmic}[1]\n\\State Input\n  \\State $\\qquad \\pi$ to be evaluated\n\\State Initialize:\n  \\State $\\qquad V(s) \\leftarrow x \\in \\mathbb{R}$, arbitrarily, $\\forall s \\in \\mathcal{S}$\n  \\State $\\qquad Returns(s)$ an empty list, $\\forall s \\in \\mathcal{S}$\n\\For {each episode:}\n    \\State Generate an episode by following $\\pi: S_0, A_0, R_1, S_1, A_1, R_2,\\ldots, S_{T-1}, A_{T-1}, R_T$\n    \\State $G \\leftarrow 0$\n    \\For {each step of episode, $t = T-1, T-2,\\ldots, 0$:}\n      \\State $G \\leftarrow \\gamma G + R_{t+1}$\n      \\State Append $G$ to $Returns(S_t)$\n      \\State $V(S_t) \\leftarrow average(Returns(S_t))$\n    \\EndFor\n\\EndFor\n\\end{algorithmic}\n\\end{algorithm}\n```\n:::\n\n::: {#nte-mc-value-prediction-first-visit .callout-note .alg}\n### MC prediction fist visit for estimating $V \\approx v_\\pi$ {#alg-mc-prediction-first-visit}\n\n``` pseudocode\n#| label: alg-mc-prediction-first-visit\n#| html-indent-size: \"1.2em\"\n#| html-comment-delimiter: \"#\"\n#| html-line-number: true\n#| html-line-number-punc: \":\"\n#| html-no-end: false\n#| pdf-placement: \"htb!\"\n#| pdf-line-number: true\n\\begin{algorithm}\n\\caption{MCAnyVisitValuePrediction($\\pi$)} \n\\begin{algorithmic}[1]\n\\State Input\n  \\State $\\qquad \\pi$ to be evaluated\n\\State Initialize:\n  \\State $\\qquad V(s) \\in \\mathbb{R}$, arbitrarily, $\\forall s \\in \\mathcal{S}$\n  \\State $\\qquad Returns(s)$ an empty list, $\\forall s \\in \\mathcal{S}$\n\\For {each episode:}\n  \\State Generate an episode by following $\\pi: S_0, A_0, R_1, S_1, A_1, R_2,\\ldots, S_{T-1}, A_{T-1}, R_T$\n  \\State $G \\leftarrow 0$\n  \\For {each step of episode, $t = T-1, T-2,\\ldots, 0$:}\n    \\State $G \\leftarrow \\gamma G + R_{t+1}$\n    \\If{$S_t \\not \\in S_0, S_1,\\ldots,S_{t-1}$}\n      \\State Append $G$ to $Returns(S_t)$\n      \\State $V(S_t) \\leftarrow average(Returns(S_t))$\n    \\EndIf\n  \\EndFor\n\\EndFor\n\\end{algorithmic}\n\\end{algorithm}\n```\n:::\n\n::: callout-caution\n### Any visit / First-visit\n\nThe book uses presents a small variation called the *first visit MC method*, We considered the any-visit case. This estimates $v_\\pi(s)$ using the average of the returns following an episode's first visit to $s$, whereas this the every-visit MC algorithms averages the returns following all visits to $s$\n:::\n\n::: callout-important\n### Intuition for the Algorithm {.unnumbered}\n\n![Efficient returns calculations](img/rl-mc-calc.png){.column-margin group=\"slides\"}\n\nThe main idea is to use the recursive nature of the returns which is embodied in the following formula:\n\n$$\nNewEstimate \\leftarrow OldEstimate + StepSize[Target - OldEstimate] \\qquad \\text{(incremental update rule)}\n$$ {#eq-incremental-update-rule}\n\nThe key to understanding this algorithm is represented in the following diagram. At the top is a backup diagram for an discounted episode.\n\nMartha explain that the MC uses the recursive nature of the returns to efficiently compute the average returns for each state by starting at the end of the episode and working backwards.\n\nWe can see that the returns from a series of equations that can be solved by substitution. Each return is the current reward and the discounted previous return that has been computed.\n\nThus we can compute all the returns for a state in a single pass through the episode. by solving this series of the full \"telescoping\" equations.\n:::\n\nthis bring us to our second example:\n\n::: {#exm-black-jack-mdp}\n### Blackjack MDP\n\n![Blackjack example](img/rl-bj-example.png){.column-margin group=\"slides\"}\n\n-   **Undiscounted** MDP where each game of blackjack corresponds to an episode with\n    -   Rewards:\n        -   r= -1 for a loss\n        -   r= 0 for a draw\n        -   r= 1 for a win\n    -   Actions : $a\\in \\{\\text{Hit}, \\text{Stick}\\}$\n    -   States S:\n        -   player has a usable ace (Yes/No) [^2]\n        -   sum of cards (12-21)[^3]\n        -   The card the dealer's card shows (Ace-10)\n    -   Cards are dealt with replacement[^4]\n    -   Policy $\\pi$:\n        -   if sum \\< 20, stick\n        -   otherwise, hit\n:::\n\n[^2]: worth either 1 or 11\n\n[^3]: face card are worth 10\n\n[^4]: this is a big simplifying assumption\n\nIn the programming assignment we will produce the following graphs\n\n![Blackjack outcomes](img/rl-bj-outcomes.png){.column-margin group=\"slides\"}\n\n-   In real world settings we typical don't know theoretical functions like values, action values or rewards. Out best option is to sample reality in trial and error experiment of testing different interventions.\n-   However under certain conditions such samples may be enough to perform the [prediction task](#dfn-prediction) learn a [value function](#dfn-value) or the [action value function](#dfn-action-value) .\n-   We can these function to learn better policies from this experience.\n-   A second scenario involves historical samples collected from past interactions. We can use probabilistic methods like MCMC to estimate $q(a)$.\n\nwe can use the MC prediction alg to estimate the expected returns for a state given a policy $\\pi$\n\n::: callout-note\nThe key limitations of *MC value estimation algorithm* is its requirement for episodic tasks and for completing such an episode before it starts. In some games an episode can be very long.\n:::\n\n::: callout-note\n## :bulb: Is this really so? :thinking:\n\n-   If we work in the Bayesian paradigm with some prior and use Bayesian updating.\n-   At every step we should have well defined means.\n-   So it seems one can perhaps do sample based on non-episodic tasks\n-   One more idea is to treat n_steps as an episode.\n-   Without episodic we most likely lose the efficient updating. :thinking:\n-   Perhaps we can use the online update rule for the mean.\n:::\n\n-   [ ] TODO - try to implement this as an algorithm.\n\n-   To ensure well-defined average sample returns, we define Monte Carlo methods only on episodic tasks that all eventually terminate - only on termination are value estimates and policies updated.\n\nImplications of MC Learning\n\n-   We don't need to keep a large mode of the environment.\n-   We estimate the values of each state independently of other states\n-   Computation for updating values or each state is independent of the size of the MDP[^5]\n\n[^5]: in DP we had to solve $n\\times n$ - simultaneous equations\n\n# Lesson 2: Monte Carlo for Control {#sec-mc-control}\n\n::: callout-note\n### Lesson Learning Goals {.unnumbered}\n\n-   [ ] Estimate action-value functions using [Monte Carlo](#dfn-mc) [\\#](#sec-l2g1)\n-   [ ] Understand the importance of maintaining exploration in Monte Carlo algorithms [\\#](#sec-l2g2)\n-   [x] Understand how to use [Monte Carlo](#dfn-mc) methods to implement a GPI algorithm. [\\#](#sec-l2g3)\n-   [x] Apply [Monte Carlo](#dfn-mc) with exploring starts to solve an MDP [\\#](#sec-l2g4)\n:::\n\n## MC Action-Value Functions {#sec-l2g1}\n\n![action values](img/rl-mc-action-values.png){.column-margin group=\"slides\"}\n\n![back off](img/rl-mc-backoff.png){.column-margin group=\"slides\"}\n\nThis back off diagram indicates that the value of a state S depends on the values of its actions.\n\n-   Recall that [control](#def-contol) is simply improving a policy using our action values estimate.\n-   Policy improvement is done by **Greedyfying** a policy $\\pi$ at a state $s$ by selecting the action $a$ with the highest action value.\n-   If we are missing some action values we can make the policy worse!\n-   We need to ensure that our RL algorithm engages the different actions of a state. There are two strategies:\n    -   Exploring starts\n    -   $\\epsilon$-Soft strategies\n\n![exploring starts](img/rl-exploring-starts.png){.column-margin group=\"slides\"}\n\nThe following is the MC alg with exploring start for estimation.\n\n![exploring starts pseudocode](img/rl-monte-carlo-GPI-01.png){.column-margin group=\"slides\"}\n\nLet's recap how GPI looks:\n\n-   Keeping $\\pi_0$ fixed we do evaluation of $q_\\pi$ using MC--ES\n-   We improve $\\pi_0$ by picking the actions with the highest values\n-   We stop when we don't improve $\\pi$\n\nHere, in the evaluation step, we estimate the action-values using MC prediction, with exploration driven by exploring Starts or an $\\epsilon$-soft policy\n\n# Lesson 3: Exploration Methods for Monte Carlo\n\n::: callout-note\n### Lesson Learning Goals {.unnumbered}\n\n-   [x] Understand why Exploring Starts can be problematic in real problems [\\#](#sec-l3g1)\n-   [x] Describe an alternative exploration method for Monte Carlo control [\\#](#sec-l3g2)\n:::\n\nNext we look into using exploring starts to learn action values using MC sampling.\n\nRecall that we like action values over state values since they allow us to find optimal policies by quickly picking the best action in a state.\n\nMr White explains that we can't use a deterministic policy to learn action values since we need to explore multiple actions in a state to pick the best one. To do this with a deterministic policy we use exploring starts - this means we start each simulation with a random state and action then follow the policy. This should eventually allow us to learn the action values for all actions in all states.\n\nSo here is how can use exploring starts or some other exploration strategy to ensure that we can learn the action values for all actions in all states.\n\n::: callout-note\n### Monte Carlo Exploring Start {#alg-mc-es-control}\n\n``` pseudocode\n#| label: alg-mc-es-control\n#| html-indent-size: \"1.2em\"\n#| html-comment-delimiter: \"#\"\n#| html-line-number: true\n#| html-line-number-punc: \":\"\n#| html-no-end: false\n#| pdf-placement: \"htb!\"\n#| pdf-line-number: true\n\\begin{algorithm}\n\\caption{MonteCarloExploringStartsGPI()}\n\\begin{algorithmic}[1]\n\\State Initialize:\n  \\State $\\qquad \\pi(s) \\in A(s) \\quad \\forall s\\in \\mathcal{S}$\n  \\State $\\qquad Q(s,a) \\leftarrow x \\in \\mathbb{R} \\quad \\forall s \\in \\mathcal{S}, a \\in \\mathcal{A}(s)$\n  \\State $\\qquad Returns(s,a) \\leftarrow \\text {an empty list} \\quad \\forall s \\in \\mathcal{S}, a \\in \\mathcal{A}(s)$\n\\For {each episode:}\n  \\State Choose $S_0 \\in \\mathcal{S}  and A_0 \\in \\mathcal{A}(S_0) \\text{randomly :} p(s,a)>0 \\forall s,a$ \\comment{$\\textcolor{blue}{Exploring Starts}$}\n  \\State Generate an episode e from  $S_0, A_0$ by following $\\pi: S_0, A_0, R_1,\\ldots, S_{T-1}, A_{T-1}, R_T$\n  \\State $G \\leftarrow 0$\n  \\For {each step of $e, t \\in T-1, T-2,..., 0:}  \\comment{$\\textcolor{blue}{Backward\\ pass}$}\n    \\State $G \\leftarrow \\gamma G + R_{t+1}$\n    \\IF {$S_t , A_t \\not \\in S_0 , A_0 , S_1 , A_1 \\ldots , S_{t-1} , A_{t-1}$}\n      \\State Append $G$ to $Returns(S_t,A_t)$\n      \\State $Q(S_t,A_t) \\leftarrow average(Returns(S_t,A_t))\\quad$ \\comment{$\\textcolor{blue}{\\text{MC action-value estimate}}$}\n      \\State $\\pi(S_t) \\leftarrow \\arg\\max_a Q(S_t,a)\\quad$ \\comment{$\\textcolor{blue}{\\text{greedy policy improvement}}$}\n    \\EndIf\n  \\EndFor\n\\EndFor\n\\end{algorithmic}\n\\end{algorithm}\n```\n:::\n\n::: callout-tip\n### Connecting the dots: MC vs DP {.unnumbered}\n\nAdam White points out how this is so much simpler than the DP methods we learned earlier. We don't need to solve a set of simultaneous equations. We can just use the MC method to estimate the action values and then use GPI to improve the policy. The only thing we need to do is to ensure that we explore all the actions in all the states.\n:::\n\n### Challenges for exploring starts {#sec-l3g1}\n\nExploring start can be problematic as we may not able to say try all actions on all states.\n\n-   there may be too many states actions to try\n-   testing certain actions in certain states it could be unethical [^6] or risky [^7]\n-   it could cost too much - we need too many experiments.\n\n[^6]: think of a medical trial\n\n[^7]: think of a self driving car\n\nNote: The Blackjack MDP can be improved using Exploring Starts since each initial state can be sampled. Recall there were 200 states.\n\n### œµ-Soft Policies {#sec-l3g2}\n\nAN ALTERNATIVE approach to policy improvement is an generalization of both the $\\epsilon$- greedy policy and the random uniform, which we first learned in the contexts of the multi-armed bandits problem in the fundamentals course.\n\nœµ-soft policy\n\n:   An œµ-soft policy is one for which in each state, all actions have a probability of at least $\\frac{\\epsilon}{|A|}$\n\nThe advantages of using an $\\epsilon$-soft policy are: - we get a never ending exploration\n\nHowever this means we can never reach a deterministic optimal policy - but we can get to a stochastic policy where the best choice is $1-\\epsilon+\\frac{\\epsilon}{|A|}$\n\nWe can get to a deterministic policy if we use a decaying $\\epsilon$-greedy policy or if we greedify the policy breaking ties randomly.\n\n::: callout-note\n### MC control with œµ-soft policies {#alg-mc-control}\n\n``` pseudocode\n#| label: alg-mc-œµ-soft-control\n#| html-indent-size: \"1.2em\"\n#| html-comment-delimiter: \"#\"\n#| html-line-number: true\n#| html-line-number-punc: \":\"\n#| html-no-end: false\n#| pdf-placement: \"htb!\"\n#| pdf-line-number: true\n\\begin{algorithm}\n\\caption{MonteCarloœµ-SoftControl()} \n\\begin{algorithmic}[1]\n\\State Initialize\n  \\State $\\qquad \\epsilon \\in (0,1)$ \\Comment{ $\\textcolor{blue}{\\ algorithm\\ parameter}$}\n  \\State $\\qquad \\pi \\leftarrow \\epsilon$-soft policy \\Comment{  $\\textcolor{blue}{\\ Initialize: policy}$}\n  \\State $\\qquad Q(s) \\leftarrow x \\in \\mathbb{R} \\forall s \\in \\mathcal{S}$\n  \\State $\\qquad Returns(s)$ an empty list, $\\quad \\forall s \\in \\mathcal{S}$\n\\For {each episode:}\n  \\State Generate an episode by following $\\pi: S_0, A_0, R_1,\\ldots, S_{T-1}, A_{T-1}, R_T$\n  \\State $G \\leftarrow 0$\n  \\For {each step of episode, $t \\in T-1, T-2,..., 0$:}\n    \\State $G \\leftarrow \\gamma G + R_{t+1}$\n    \\State Append $G$ to $Returns(S_t,A_t)$\n    \\State $Q(S_t,A_t) \\leftarrow average(Returns(S_t,A_t))$\n    \\State $A^* \\leftarrow \\arg\\max_a Q(S_t,a) \\qquad \\textcolor{blue}{\\text{(ties broken arbitrarily)}}$\n    \\For {each $a \\in \\mathcal{A}$}\n      \\If{$a = A^*$}\n        \\State $\\pi(a \\mid S_t) \\leftarrow 1 - \\epsilon + \\frac{\\epsilon}{|A(S_t)|}$\n      \\Else\n        \\State $\\pi(a \\mid S_t) \\leftarrow \\frac{\\epsilon}{|A(S_T)|}$\n      \\EndIf\n    \\EndFor\n  \\EndFor\n\\EndFor\n\\end{algorithmic}\n\\end{algorithm}\n```\n:::\n\nThe Highlights indicate modification of the Exploring Starts alg\n\n1.  We can start with Uniform-random as its epsilon-soft.\n2.  Episode generation uses the current $\\pi$ ($\\epsilon$-soft policy) *before* it is improved.\n3.  We drop the first-visit check - this is an every-visit MC algorithm.\n4.  The new policy generated in each iteration is $\\epsilon$-greedy w.r.t. the current action-value estimate, which is improved prior.\n5.  The optimal $\\epsilon$-soft policy is an $\\epsilon$-soft policy.\n\n## Lesson 4: Off-policy learning for prediction\n\n::: callout-note\n## Lesson Learning Goals {.unnumbered}\n\n-   [ ] Understand how off-policy learning can help deal with the exploration problem [\\#](#sec-l4g1)\n-   [ ] Produce examples of target policies and examples of behavior policies. [\\#](#sec-l4g2)\n-   [ ] Understand importance sampling [\\#](#sec-l4g3)\n-   [ ] Use importance sampling to estimate the expected value of a target distribution using samples from a different distribution. [\\#](#sec-l4g4)\n-   [ ] Understand how to use importance sampling to correct returns [\\#](#sec-l4g5)\n-   [ ] Understand how to modify the Monte Carlo prediction algorithm for off-policy learning. [\\#](#sec-l4g6)\n:::\n\n### Off-policy learning {#sec-l4g1}\n\n-   Off-policy learning is a way to learn a policy $\\pi$ using samples from another policy $\\pi'$.\n-   This is useful when we have a policy that is easier to sample from than the policy we want to learn.\n-   A key idea is to correct the returns using importance sampling.\n\nFor example suppose we can use a rule based model to generate samples of agent state, action and rewards - but we don't really have an MDP, value function or policy. We could start with a uniform random policy and then use the samples to learn a better policy. However this would require us to interact with the environment and our agents may not be able to do this. In the case of Sugarscape model the agents are not really making decisions, they are following rules.\n\nIf we wished to develop agent that learn using RL with different rules on or off and other settings and use those to learn a policy using many samples. One advantage of the Sugarscape model is that it is highly heterogeneous so we get a rich set of samples to work with. A second advantage is that the rule based model can be fast to sample from and we can generate many samples by running it using hyper-parameters optimized test-bed.\n\nSo if we have lots of samples we may not need to explore as much initially, but rather learn to exploit the samples we have. Once we learn a near optimal policy for the samples we can use our agent to explore new vistas in our environment.\n\n### Target and behavior policies {#sec-l4g2}\n\n-   The target policy is the policy we want to learn.\n-   The behavior policy is the policy we sample from.\n\n### Importance sampling {#sec-l4g3}\n\n-   Importance sampling is a technique to estimate the expected value of a target distribution using samples from a different distribution.\n-   Why cant we just use the samples from the behavior policy to estimate the target policy?\n-   The answer is that the samples from the behavior policy are biased towards the behavior policy.\n-   In the target policy we may have states that are never visited by the behavior policy.\n-   For example we might want to learn a policy that focuses on trade rather than combat or Vica-versa. This extreme idea of introducing/eliminating some action would significantly change behavioral trajectories. Sample based methods could be able to handle these changes - if we can restrict them to each subset of actions but clearly the expected return of states will be diverge in the long run.\n-   So what we want is someway to correct the returns from the behavior policy to the target policy.\n-   It is used to correct returns from the behavior policy to the target policy.\n\nThe probability of a trajectory under $\\pi$ is:\n\n$$\n\\begin{align*}\n  P(A_t, S_{t+1}, & A_{t+1}, ... ,S_T | S_t, A_{t:T-1} \\sim \\pi) \\newline\n  & = \\pi(A_t|S_t)p(S_{t+1}|S_t, A_t)\\pi(A_{t+1}, S_{t+1}) \\cdot\\cdot\\cdot p(S_T|S_{T-1}, A_{T-1}) \\newline\n  & = \\prod_{k=t}^{T-1} \\pi(A_k|S_k)p(S_{k+1}|S_k, A_k)\n\\end{align*}\n$$ {#eq-trajectory-probability}\n\n### Importance sampling ratio {#sec-l4g4}\n\n**Definition:** The importance sampling ratio (rho, $\\rho$) is the relative probability of the trajectory under the target vs behavior policy:\n\n$$\n\\begin{align}\n\\rho_{t:T-1} & \\doteq \\frac{\\prod_{k=t}^{T-1} \\pi(A_k \\mid S_k) \\cancel{ p(S_{k+1} \\mid S_k, A_k)}}{\\prod_{k=t}^{T-1} b(A_k \\mid S_k) \\cancel{ p(S_{k+1} \\mid S_k, A_k)} } \\newline\n             & = \\prod_{k=t}^{T-1} \\frac{\\pi(A_k \\mid S_k)}{b(A_k \\mid S_k)}\n\\end{align}\n$$ {#eq-importance-sampling}\n\n$$\nv_\\pi(s) = \\mathbb{E}_b[\\rho_{t:T-1} \\cdot G_t \\mid S_t = s] \\qquad\n$$ {#eq-value1}\n\n$$\nV(s) \\doteq \\frac{\\displaystyle \\sum_{t\\in \\mathscr T(s)}\\rho_{t:T(t) - 1} \\cdot G_t}{|\\mathscr T (s)|} \\qquad\n$$ {#eq-weighted-importance-sampling}\n\n$$\nV(s) \\doteq \\frac{\\displaystyle \\sum_{t\\in \\mathscr T(s)} \\Big(\\rho_{t:T(t) - 1} \\cdot G_t\\Big)}{\\displaystyle \\sum_{t\\in \\mathscr T(s)}\\rho_{t:T(t) - 1}} \\qquad\n$$ {#eq-weighted-importance-sampling2}\n\n![importance sampling example](img/wk2-importance-sampling-example.png){.column-margin group=\"slides\"}\n\n![off policy trajectories](img/wk2-off-policy-trajectories.png){.column-margin group=\"slides\"}\n\n::: callout-note\n### Off-policy every visit MC prediction {#alg-off-policy-mc-predictions}\n\n``` pseudocode\n#| label: alg-mc-off-policy-prediction\n#| html-indent-size: \"1.2em\"\n#| html-comment-delimiter: \"#\"\n#| html-line-number: true\n#| html-line-number-punc: \":\"\n#| html-no-end: false\n#| pdf-placement: \"htb!\"\n#| pdf-line-number: true\n\n\\begin{algorithm}\n\\caption{OffPolicyMonteCarloPrediction()} \n\\begin{algorithmic}[1]\n\\State Input:\n  \\State $\\qquad \\pi \\leftarrow \\text{policy to be evaluated}$\n\\State Initialize:\n  \\State $\\qquad V(s) \\leftarrow x \\in \\mathbb{R} \\forall s \\in \\mathcal{S}$\n  \\State $\\qquad Returns(s) \\text{ an empty list,} \\quad \\forall s \\in \\mathcal{S}$\n\\For {each episode:}\n  \\State Generate an episode by following $\\pi: S_0, A_0, R_1,\\ldots, S_{T-1}, A_{T-1}, R_T$\n  \\State $G \\leftarrow 0, W \\leftarrow 1$\n  \\For {each step of episode, $t \\in T-1, T-2,..., 0$:}\n    \\State $G \\leftarrow \\gamma WG + R_{t+1}$\n    \\State Append $G$ to $Returns(S_t)$\n    \\State $V(S_t) \\leftarrow average(Returns(S_t))$\n    \\State $W \\leftarrow W \\frac{\\pi(A_t|S_t)}{b(A_t|S_t)}$\n  \\EndFor\n\\EndFor\n\\end{algorithmic}\n\\end{algorithm}\n```\n:::\n\n::: callout-note\n### Off-policy every visit MC control {#alg-off-control-mc-predictions}\n\n``` pseudocode\n#| label: alg-mc-off-control-prediction\n#| html-indent-size: \"1.2em\"\n#| html-comment-delimiter: \"#\"\n#| html-line-number: true\n#| html-line-number-punc: \":\"\n#| html-no-end: false\n#| pdf-placement: \"htb!\"\n#| pdf-line-number: true\n\n\\begin{algorithm}\n\\caption{OffPolicyMonteCarloPrediction()} \n\\begin{algorithmic}[1]\n\\State Input:\n  \\State $\\qquad \\pi \\leftarrow \\text{policy to be evaluated}$\n\\State Initialize:\n  \\State $\\qquad V(s) \\leftarrow x \\in \\mathbb{R} \\forall s \\in \\mathcal{S}$\n  \\State $\\qquad Returns(s) \\text{ an empty list,} \\quad \\forall s \\in \\mathcal{S}$\n\\For {each episode:}\n  \\State Generate an episode by following $b: S_0, A_0, R_1,\\ldots, S_{T-1}, A_{T-1}, R_T$\n  \\State $G \\leftarrow 0, W \\leftarrow 1$\n  \\For {each step of episode, $t = T-1, T-2,\\ldots, 0$:}\n    \\State $G \\leftarrow \\gamma WG + R_{t+1}$\n    \\State Append $G$ to $Returns(S_t)$\n    \\State $V(S_t) \\leftarrow average(Returns(S_t))$\n    \\State $W \\leftarrow W \\frac{\\pi(A_t  \\mid S_t)}{b(A_t \\mid S_t)}$\n  \\EndFor\n\\EndFor\n\\end{algorithmic}\n\\end{algorithm}\n```\n:::\n\n### Emma Brunskill: Batch Reinforcement Learning\n\nThese guest talks have a dual purpose:\n\n1.  to let the speakers share their passion for the field and introduce us to their research. this can be a good start for reading more about our own interests or for looking how to solve real problems that we are facing.\n2.  to show us how the concepts we are learning are being used in the real world.\n\n-   [Emma Brunskill](https://cs.stanford.edu/people/ebrun/) is a professor at Stanford University.\n-   Burnskill motivated her approach with an edutainment app in which the goal is to maximize student engagement in game based on historical data.\n-   In batch RL we have a fixed dataset of samples and we want to learn a policy from this data.\n-   This is useful when we have a fixed dataset of samples and we want to learn a policy from this data.\n-   The key idea is to use importance sampling to correct the returns from the behavior policy to the target policy. We learned that the challenge this poses is primarily due to the bias of the behavior policy.\n-   [Importance sampling provides us with an unbiased estimate of the value function yet can have high variance]{.marked}. These may can be exponentially large in the number of steps. So these results in very poor estimates for the value function if there are many steps in the trajectory.\n-   Brunskill suggest that [the real challenge posed by batch RL is a sparsity of trajectories with actions leading to optimal next states under the target policy]{.marked} in the historical data.[^8]\n-   One point we learned about this is that we should seek algorithms that are more data efficient. However\n-   A send idea is to use parametric models which are biased by can learn the transition dynamics and the reward function more efficiently.\n-   Brunskill points out that since we have few samples we may need a better approach to get robust estimates of the value function.\n-   This approach which comes from statistic is called [doubly robust stimators]() and has been used in bandits and RL\n-   She presents a chart from a 2019 paper with a comparison of different methods for RL in the cart-pole environment.\n    -   Off policy policy gradient with state Distribution Correction - dominates the other methods. And has a significantly narrower confidence interval for the value, if I understand the figure correctly.\n-   She also presents results from many papers on Generalization Guarantees for RL, which show that we can learn a policy that is close to the optimal policy with a small number of samples from another policy. However I cannot make much sense of the result in the slide.\n-   An example of this is the Sugarscape model where we have a fixed dataset of samples from the rule-based model.\n-   More generally, we can use batch RL to learn from historical data how to make better decisions in the future.\n\n[^8]:\n    -   Can we learn form one or two examples by sampling ?\n    -   what if the good actions are never sampled by our algorithm?\n\nCounterfactual\n\n:   You don't know what your life would be like if you weren't reading this right now.\n\n-   Causal reasoning based on counterfactuals is a key idea to tackling this problem.\n\nCounterfactual or Batch Reinforcement Learning\n\n:   In batch RL we have a fixed dataset of samples and we want to learn a new policy from this data.\n\n::: callout-note\n### Doubly Robust Estimators {.unnumbered}\n\n[Doubly robust estimators](https://en.wikipedia.org/wiki/Inverse_probability_weighting#Interpretation_and_%22double_robustness%22) is a technique from statistics that and causal inference that allows us to combine to do importance sampling and model based learning and a propensity score to estimate the value function. combine the best of both worlds - they are robust to errors in the model and the policy.\n\n$$\n\\hat V_{DR} =\\frac{1}{N} \\sum_{i=1}^N \\left[ \\rho_i (R_i + \\gamma Q(s_{i+1}, \\pi(s_{i+1}))) - \\rho_i \\hat Q_{\\pi}(s_i, a_i) + \\hat Q_{\\pi}(s_i, a_i) \\right]\n$$ where:\n\n-   $\\rho_i$ is the importance sampling ratio for the $i$-th sample\n-   $R_i$ is the reward - $Q(s_{i+1}, \\pi(s_{i+1}))$ is the value of the next state under the target policy\n-   $\\hat Q_{\\pi}(s_i, a_i)$ is the model based Q-function estimate\n-   $Q(s_{i+1}, \\pi(s_{i+1}))$ is the value of the next state under the target policy\n:::\n\n\n\n\n{{< video https://www.youtube.com/embed/ADD4B0bOZi4 >}}\n\n\n\n\n\n\nand paper\n\n-   [Provably Good Batch Reinforcement Learning Without Great Exploration](https://arxiv.org/abs/2007.08202)\n-   [Data-Efficient Off-Policy Policy Evaluation for Reinforcement Learning](https://arxiv.org/abs/1604.00923)\n\n",
    "supporting": [
      "c2-w1_files"
    ],
    "filters": [],
    "includes": {}
  }
}